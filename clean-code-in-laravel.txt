

Using the dependency injection, which makes the code more testable and flexible.
The Laravel service container is powerful for managing class dependencies and performing dependency injection.

Eg:

use Illuminate\Contracts\Cache\Repository as Cache;

public function __construct(Cache $cache)

{

    $this->cache = $cache;

}

public function index()

{

    $users = $this->cache->remember(‘users’, 60, function () {

    return User::all();

    });

}


Another example is the use of raw SQL queries instead of Eloquent ORM.
Eloquent provides a more readable, maintainable, and secure way to interact with the database.

Shifting to Eloquent ORM can significantly reduce the risk of SQL injection.
Eloquent automatically handles escaping user input, ensuring that any data passed to queries is properly sanitized.

For example, instead of writing raw SQL queries like this:
$query = "SELECT * FROM users WHERE email = '$email'";

Eloquent would allow you to do this:
$user = User::where('email', $email)->first();


# Scope Queries
Scope queries in Laravel are custom query constraints that you define in your Eloquent models.
These scopes allow you to encapsulate commonly used query logic and reuse it across your application.

Example:
You might frequently need to fetch only active users or filter posts by their published date.
You can define a scope to handle these queries.


// In User model
public function scopeActive($query)
{
    return $query->where('status', 'active');
}

// Usage:
$activeUsers = User::active()->get();

# Eager Loading

To avoid this, use eager loading with the with method:
$posts = Post::with('comments')->get();  // Eager load comments with posts in a single query

foreach ($posts as $post) {
    echo $post->comments;  // No extra queries for comments
}

#Adopt Repository Pattern for Database Interaction
For complex applications, adopting the repository and service patterns can help decouple your application from Laravel’s Eloquent ORM.
This will make your codebase more testable, maintainable, and adaptable to future changes.

    For example, if you have a Post model, create an interface like this:
    namespace App\Repositories;

interface PostRepositoryInterface
{
    public function getAll();
    public function find($id);
    public function create(array $data);
    public function update($id, array $data);
    public function delete($id);
}

 Create a Concrete Repository Class
namespace App\Repositories;

use App\Models\Post;

class PostRepository implements PostRepositoryInterface
{
    protected $model;

    public function __construct(Post $post)
    {
        $this->model = $post;
    }

    public function getAll()
    {
        return $this->model->all();
    }

    public function find($id)
    {
        return $this->model->find($id);
    }

    public function create(array $data)
    {
        return $this->model->create($data);
    }

    public function update($id, array $data)
    {
        $post = $this->model->find($id);
        return $post ? $post->update($data) : null;
    }

    public function delete($id)
    {
        $post = $this->model->find($id);
        return $post ? $post->delete() : null;
    }
}

    Now, you need to bind the interface to the concrete repository class in a service provider.
    You can do this in the AppServiceProvider or create a new one.

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Repositories\PostRepositoryInterface;
use App\Repositories\PostRepository;

class AppServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->bind(PostRepositoryInterface::class, PostRepository::class);
    }

    public function boot()
    {
        //
    }
}

  In your controllers, you can inject the repository interface and use it to interact with the database.
  namespace App\Http\Controllers;

  use App\Repositories\PostRepositoryInterface;

  class PostController extends Controller
  {
      protected $postRepository;

      public function __construct(PostRepositoryInterface $postRepository)
      {
          $this->postRepository = $postRepository;
      }

      public function index()
      {
          $posts = $this->postRepository->getAll();
          return view('posts.index', compact('posts'));
      }

      public function show($id)
      {
          $post = $this->postRepository->find($id);
          return view('posts.show', compact('post'));
      }

      // Other controller actions can follow...
  }
