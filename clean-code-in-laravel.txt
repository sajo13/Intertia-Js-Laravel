Source: https://medium.com/@elijah_williams_agc/10-tips-for-updating-your-laravel-coding-techniques-55a966a2912c

Using the dependency injection, which makes the code more testable and flexible.
The Laravel service container is powerful for managing class dependencies and performing dependency injection.

Eg:

use Illuminate\Contracts\Cache\Repository as Cache;

public function __construct(Cache $cache)

{

    $this->cache = $cache;

}

public function index()

{

    $users = $this->cache->remember(‘users’, 60, function () {

    return User::all();

    });

}


Another example is the use of raw SQL queries instead of Eloquent ORM.
Eloquent provides a more readable, maintainable, and secure way to interact with the database.

Shifting to Eloquent ORM can significantly reduce the risk of SQL injection.
Eloquent automatically handles escaping user input, ensuring that any data passed to queries is properly sanitized.

For example, instead of writing raw SQL queries like this:
$query = "SELECT * FROM users WHERE email = '$email'";

Eloquent would allow you to do this:
$user = User::where('email', $email)->first();


# Scope Queries
Scope queries in Laravel are custom query constraints that you define in your Eloquent models.
These scopes allow you to encapsulate commonly used query logic and reuse it across your application.

Example:
You might frequently need to fetch only active users or filter posts by their published date.
You can define a scope to handle these queries.


// In User model
public function scopeActive($query)
{
    return $query->where('status', 'active');
}

// Usage:
$activeUsers = User::active()->get();

# Eager Loading

To avoid this, use eager loading with the with method:
$posts = Post::with('comments')->get();  // Eager load comments with posts in a single query

foreach ($posts as $post) {
    echo $post->comments;  // No extra queries for comments
}

#Adopt Repository Pattern for Database Interaction
For complex applications, adopting the repository and service patterns can help decouple your application from Laravel’s Eloquent ORM.
This will make your codebase more testable, maintainable, and adaptable to future changes.

    For example, if you have a Post model, create an interface like this:
    namespace App\Repositories;

interface PostRepositoryInterface
{
    public function getAll();
    public function find($id);
    public function create(array $data);
    public function update($id, array $data);
    public function delete($id);
}

 Create a Concrete Repository Class
namespace App\Repositories;

use App\Models\Post;

class PostRepository implements PostRepositoryInterface
{
    protected $model;

    public function __construct(Post $post)
    {
        $this->model = $post;
    }

    public function getAll()
    {
        return $this->model->all();
    }

    public function find($id)
    {
        return $this->model->find($id);
    }

    public function create(array $data)
    {
        return $this->model->create($data);
    }

    public function update($id, array $data)
    {
        $post = $this->model->find($id);
        return $post ? $post->update($data) : null;
    }

    public function delete($id)
    {
        $post = $this->model->find($id);
        return $post ? $post->delete() : null;
    }
}

    Now, you need to bind the interface to the concrete repository class in a service provider.
    You can do this in the AppServiceProvider or create a new one.

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Repositories\PostRepositoryInterface;
use App\Repositories\PostRepository;

class AppServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->bind(PostRepositoryInterface::class, PostRepository::class);
    }

    public function boot()
    {
        //
    }
}

  In your controllers, you can inject the repository interface and use it to interact with the database.
  namespace App\Http\Controllers;

  use App\Repositories\PostRepositoryInterface;

  class PostController extends Controller
  {
      protected $postRepository;

      public function __construct(PostRepositoryInterface $postRepository)
      {
          $this->postRepository = $postRepository;
      }

      public function index()
      {
          $posts = $this->postRepository->getAll();
          return view('posts.index', compact('posts'));
      }

      public function show($id)
      {
          $post = $this->postRepository->find($id);
          return view('posts.show', compact('post'));
      }

      // Other controller actions can follow...
  }

## Using queues for time-consuming tasks in Laravel is an excellent way to improve the performance and responsiveness of your application. By offloading heavy tasks to a queue, you ensure that the user doesn’t have to wait for these tasks to complete before receiving a response.

Here’s how you can use queues in Laravel:

To set up a queue driver, open your .env file and specify your preferred driver:
QUEUE_CONNECTION=database

Create a Job
You can create a job class using the Artisan command:
    php artisan make:job SendEmail

    public function handle()
    {
        Mail::to($this->user->email)->send(new WelcomeEmail($this->user));
    }


Dispatch the Job
To dispatch the job to the queue, use the dispatch() method:
    SendEmail::dispatch($user);

 Process the Queue
To process jobs, you need to run the queue worker.
You can start a worker in the terminal with this command:
php artisan queue:work


Handling Failed Jobs
If a job fails, Laravel provides built-in support for failed job handling. You can configure failed job storage in the config/queue.php file. You can retry failed jobs or inspect them later.

For example, you can check for failed jobs with:
php artisan queue:failed

